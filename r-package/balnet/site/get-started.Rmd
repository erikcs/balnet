```{r, echo=FALSE}
set.seed(42)
```

# Introduction to `balnet`

This vignette gives a brief overview of the `balnet` package.
A commonly used method for estimating propensty scores for use in observational studies, is to use logistic regression, with, depending on data size and application, a regularization penalty.
`balnet` estimates regularized logistic regression models, except it does so using covariate balancing loss functions with a logistic link instead of traditional maximum likelihood. A property of these loss functions, is that they automatically ensure covariate balance for uses-cases in inverse probability weighting (IPW).
The following example gives a brief demonstration.


We begin by simulating a small toy example. Here, units with particular values of the pre-treatment covariate $X_1$ are less likely to be included in the treatment arm.
```{r}
library(balnet)

n <- 100
p <- 25
X <- matrix(rnorm(n * p), n, p)
W <- rbinom(n, 1, 1 / (1 + exp(1 - X[, 1])))
```

If we are interested in estimating an average treatment effect (ATE), we can fit a `balnet` object with default options. This fits a lasso regularization path with options that reflect typical `glmnet` usage.
```{r}
fit <- balnet(X, W)
```

A few details are worth pointing out. Firstly, when estimating propensity scores using covariate balancing loss functions, they are tailored to the particular estimand we are interested in. For the ATE, balnet fit two propensity score models, one for the control arm, and one for the treatment arm. When forming IPW estimates, we'd use the control fit to estimate the mean in the control arm $E[Y_i(0)]$ and the treated fit to estimate $E[Y_i(1))$. If we print the returned object, we see fit information for the two arms (the output is by default truncated to show the beginning and end of the path fit - the entire fit can be displayed by setting the `max` option in `print`)
```{r}
print(fit)
```

The first column of the displayed outcome should be self-explanatry and mimics the number of non-zero coefficients. Like `glmnet`, `balnet` by default starts the $\lambda$ that yields with the intercept-only model where all coefficients are zero, and continues in `nlambda` log-steps down to the $\lambda$ value that is a fraction `lambda.min.ratio` of this value. The next column displays the mean, across all covarites, of the absolute standardized mean difference (SMD). Note: `balnet` always reports and solves balance metrics on the standardized scale.

For the particular data example we simulated, it is not possible to find weights that *exactly* balances the covariate means in the treatment and control arm such that they match the overall sample means of $X$. This is reflected in the print output: for both arms, `balnet` truncated the regularization path before reaching the default path length of `nlambda = 100`. The treatment is evidently more challenging to balance than the control arm.

A few more details are worth noting before moving on. For lasso regularized generalized linear models, we often think of the penalty parameter $\lambda$ as a budget on the overall coefficients. The interpreation is different in our case. Covariate balancing loss functions are the primal of the optimization problem that finds that weight that minimize imbalance subject to balance levels. This means that for lasso, $\lambda$ is the maximum allowable absolute SMD across all covariates.

As an example, consider $\lambda_{max} \approx 0.62$ from the treatment arm printout. We can easily very this via:
```{r}
smd.baseline <- (colMeans(X[W == 1, ]) - colMeans(X)) / (apply(X, 2, sd) * sqrt((n - 1) / n))
max(abs(smd.baseline))
```

Since the lowest value of $\lambda$ `balnet` computed for the treatment arm is $\lambda_{min} \approx .21$, it means the closes we're able to get the standardized treated covariate means to the overall standardized means, is around 0.21.

This $\lambda$ property gives users a very flexible option to try and reach a desired imbalance threshold. The user can simply calcualte $\lambda_{max}$ for their dataset, then set the parameter `lambda.min.ratio` to the desired fraction of the maximum imbalance they desire. For example, if $\lambda_{max} = 10$, then a default `lambda.min.ratio = 0.01` means the maximum absolute standardized mean diffrence will be $10 * 0.01 = 0.1$. `balnet` will the attempt to compute the full path, stopping gracefully if it is not possible to achieve a lower imbalance (if the balance is only approximate, advanced users way wish to augment the IPW construction with an outcome model).

## Plotting path diagnostics
`balnet` has some default plot methods for visualizing the fit. If we call `plot` without any further arguments, we see metrics that attempt to summarize the regularization path, ranging from largest to smallest values of $\lambda$, on the log-scale.
```{r}
plot(fit)
```

The plot shows two metrics, normalized to units in percent. The first one, percent bias reduction ("PBR"), measure the reduction in the absolute standardized mean difference after weighting with the estimating propensity scores at a given $\lambda$. The second, effective sample size ("ESS") is simply the ratio of the squared sum of IPW weights, over the sums of squared wieights, normalized to sum to 100.

Recall that by default $\lambda_{max}$ equal the all zero fit, which in the balancing case corresponds to the unweighted data. The plot shows that as the penalty parameter decreases, the overall SMD is reduced, while the effective sample size decreased, as we are placing more weight on a smaller set of units.

We can also plot individual SMDs at different values of $\lambda$ by specifying the `lambda` argument. Plot shows the fit for the closest lambda queried, so a quick way to see the SMD for the smallest $\lambda$ in the path is simply calling it with `lambda = 0`.
```{r}
plot(fit, lambda = 0)
```

$\lambda_{max}$ shows the SMD for the unweighted data, the SMD for the weights corresponding to the given `lambda` is shown in colors. Two plots are shown since separate propensity models are fit for each treatment arm, with the goal of balancing the covarate means in the given arms closer to the overall covariate means. The SMD metric in `balnet` takes the form "(weighted mean covariate - target mean) / std.dev(target))".

The plots make it pretty obivous that the ATE is probably not an appropriate target parameter, given overlap issues with treatment assignment in the treated arm. We can fit a balancing loss logistic model targeting the average treatment effect on the treated (ATT) by setting `target = "ATT"`. Under the hood, `balnet` will fit a logistic model that aims to balance the control means closer to the treated means.
```{r}
fit.att <- balnet(X, W, target = "ATT")

plot(fit.att, lambda = 0)
```

We see that the this IPW weights do a quite good job.

For more functionalty, we encourage users to inspect the documentation for the standard S3 methods for `balnet`, such as `predict` for predictions, and `coef` for estimated model coefficients.
